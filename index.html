<!DOCTYPE html>
<!-- saved from url=(0032)http://127.0.0.1:5500/index.html -->
<html lang="ru">
<head>
<meta charset="utf-8">
<title>Задача «TXT2HTML»</title>
<link rel="stylesheet" href="index.css">
</head>
<body>
<header>Блог компании Яндекс.</header>
<main>
<section>
<h1>ЯНДЕKС.ПОЧТА: КАК МЫ ИЗМЕРЯЕМ СКОРОСТЬ ЗАГРУЗКИ И УЛУЧШАЕМ ЕЁ</h1>
<article>
<p>
  Если ваш сайт медленно грузится, вы рискуете тем, что люди не оценят
  ни то,какой он красивый, ни то, какой он удобный. Никому не понравится,
  когда всетормозит. Мы регулярно добавляем в Яндекс.Почту новую
  функциональность, иногда — исправляем ошибки, а это значит, у нас постоянно появляются
  новый код и новая логика. Всё это напрямую влияет на скорость работы
  интерфейса.
</p>
<article>
<h4>Этапы первой загрузки:</h4>
<ol>
<li>подготовка;</li>
<li>загрузка статики (HTTP-запрос и парсинг);</li>
<li>исполнение модулей;</li>
<li>инициализация базовых объектов;</li>
<li>отрисовка.</li>
</ol>
<h4>Этапы отрисовки любой страницы:</h4>
<ul>
<li>подготовка к запросу на сервер;</li>
<li>запрос данных с сервера;</li>
<li>шаблонизация;</li>
<li>обновление DOM.</li>
</ul>
<q>Ок, теперь у нас есть метрики, мы можем отправить их на сервер</q>- говорим мы<br>
<q>Что же дальше?</q> - вопрошаете вы<br>
<q>А давай построим график!</q> - отвечаем мы<br>
<q>А что будем считать?</q> - уточняете вы<br>
<p>
  Как вы знаете, медиана – это серединное, а не среднее значение в
  выборке.Если у нас имеются числа 1, 2, 2, 3, 8, 10, 20, то медиана – 3, а
  среднее – 6,5. В общем случае медиана отлично показывает, сколько грузится
  средний пользователь.
</p>
<p>
  В случае ускорения или замедления медиана, конечно, изменится. Но
  она не может рассказать, сколько пользователей ускорилось, а сколько
  замедлилось.
</p>
<p>
<strong><abbr title="Application Performance Index">APDEX</abbr>
  – метрика, которая сразу говорит: хорошо или плохо.</strong> Метрика
  работает очень просто. Мы выбираем временной интервал [0; t],
  такой, что если время показа страницы попало в него, то пользователь счастлив.
  Берем еще один интервал, (t; 4t] (в четыре раза больше первого), и считаем, что
  если страница показана за это время, то пользователь в целом удовлетворен
  скоростью работы, но уже не настолько счастлив. И применяем формулу:<br>
  (кол-во счастливых пользователей + кол-во удовлетворенных / 2) /
  (кол-во всех).<br>Получается значение от нуля до единицы, которое, видимо, лучше
  всего показывает, хорошо или плохо работает почта.
</p>
</article>
<article>
<h2>Как мы измеряем</h2>
<p>
  Сейчас модуль обновления сам логирует все свои стадии, и можно легко
  понять причину замедления: медленнее стал отвечать сервер либо слишком
  долго выполняется JavaScript. Выглядит это примерно так:
<br>
<code>
  this.timings['look-ma-im-start'] = Date.now();<br>
  this.timings['look-ma-finish'] = Date.now();
</code>
<br>

  C помощью <code>Date.now()</code> мы получаем текущее время. Все тайминги
  собираются и при отправке рассчитываются. На этапах разница между “end” и “start” не
  считается, а все вычисления производятся в конце:
<br>
<code>
  var totalTime = this.timings['look-ma-finish'] - this.timings['look-ma-im-start'];
</code>
<br>
  И на сервер прилетают подобные записи:
<code>
  serverResponse=50&amp;domUpdate=60
</code>
</p>
</article>
<article>
<h2>Как мы ускоряем</h2>
<p>
  Чтобы снизить время загрузки почты при выходе новых версий,
  мы уже делаем следующее:
</p>
<ul>
<li>включаем gzip;</li>
<li>выставляем заголовки кэширования;</li>
<li>фризим CSS, JS, шаблоны и картинки;</li>
<li>используем CDN;</li>
</ul>
<p>
  Мы подумали: <q>А что если хранить где-то старую версию файлов, а при
  выходе новой передавать только diff между ней и той, которая сохранена у
  пользователя?</q> В браузере же останется просто наложить патч на клиенте.
</p>

<p>
<mark>
  На самое деле эта идея не нова. Уже существуют стандарты для HTTP —
  например,RFC 3229 «Delta encoding in HTTP» и «Google SDHC», — но по разным
  причинам они не получили должного распространения в браузерах и на серверах.
</mark>
</p>
<p>
  Мы же решили сделать свой аналог на JS. Чтобы реализовать этот метод
  обновления, начали искать реализации diff на JS. На популярных хостингах кода
  нашли библиотеки:
</p>
<ul>
<li>VCDiff</li>
<li>google-diff-patch-match</li>
</ul>
  Для окончательного выбора библиотеки нам нужно сравнить:

<table>
<caption>
  Таблица сравнения.
</caption>
<tr>
<th>Библиотека</th>
<th>IE 9</th>
<th>Opera 12</th>
</tr>
<tr>
<td>vcdiff</td>
<td>8</td>
<td>5</td>
</tr>
<tr>
<td>google diff</td>
<td>1363</td>
<td>76</td>
</tr>
</table>
<p>
  После того как мы определились с библиотекой для диффа, нужно
  определиться с тем, где и как хранить статику на клиенте.
  Формат файла с патчами для проекта выглядит так:
</p>
<code>
  [
  {<br>
  "k": "jane.css",<br>
  "p": [patch],<br>
  "s": 4554<br>
  },<br>
  {<br>
  "k": "jane.css",<br>
  "p": [patch],<br>
  "s": 4554<br>
  }
  ]<br>
</code>
<p>
  То есть это обычный массив из объектов. Каждый объект — отдельный
  ресурс. У каждого объекта есть три свойства. k — названия ключа в localStorage
  для этого ресурса. p — патч для ресурса, который сгенерировал vcdiff. s —
  чексумма для ресурса актуальной версии, чтобы потом можно было проверить
  правильность наложения патча на клиенте. Чексумма вычисляется по алгоритму
  Флетчера.
</p>

            Алгоритм Бройдена — Флетчера — Гольдфарба — Шанно (BFGS)
            — итерационный метод численной оптимизации, предназначенный для
            нахождения локального максимума/минимума нелинейного функционала
            без ограничений.

            Почему именно алгоритм Флетчера, а не другие популярные алгоритмы
            вроде:
            CRC16/32 - алгоритм нахождения контрольной суммы, предназначенный
            для проверки
            целостности данных
            md5 - 128-битный алгоритм хеширования. Предназначен для создания
            «отпечатков»
            или дайджестов сообщения произвольной длины и последующей проверки
            их подлинности.

            Потому что он быстрый, компактный и легок в реализации.
</article>
<article>
<h2>Итог</h2>
<p>
  Фактически мы экономим 80-90% трафика. Размер загружаемой статитки в
  байтах:
</p>
<table>
<tr>
<th>Релиз</th>
<th>С патчем</th>
<th>Без патча</th>
</tr>
<tr>
<td>7.7.20</td>
<td>397</td>
<td>174549</td>
</tr>
<tr>
<td>7.7.21</td>
<td>383</td>
<td>53995</td>
</tr>
<tr>
<td>7.7.22</td>
<td>483</td>
<td>3995</td>
</tr>
</table>
</article>
</article>
</section>
<section>
<aside>
<div class="autor">
  Автор: @doochik
  C++ разработчик
<address>
  Электронная почта:
<a href="http://127.0.0.1:5500/doochik@yandex-team.ru">doochik@yandex-team.ru</a>
</address>
Компания: Яндекс
</div>
</aside>
</section>
<section class="comments">
        <h3>Комментарии (3):</h3>

        <h5>- Mogaika (mogaika@yandex-team.ru) 30 ноября 2014 в 17:05</h5>

        <q>А можете привести сравнение, на сколько быстрее грузится lite версия?</q>

        <h5>- JIguse (mrawesome@yandex.ru) 29 ноября 2014 в 21:30</h5>

        <q>Спасибо за статью, познавательно. Здорово, что Яндекс делится некоторыми
        подробностями о внутренней работе сервисов.</q>

        <h5>- Brister (brist89@yandex-team.ru) 24 ноября 2014 в 13:13</h5>

        <q>(кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во
        всех).
        Получается значение от нуля до единицы, которое, видимо, лучше всего
        показывает,
        хорошо или плохо работает почта.

        наверное все-таки от 0.5 до 1</q>

        <h5>- alexeimois (test@yandex.ru) 22 ноября 2014 в 17:35</h5>

        <q>Мы измеряем скорость загрузки с помощью Яндекс.Метрики:
        help.yandex.ru/metrika/reports/monitoring_timing.xml</q>

</section>
</main>
<hr>
<footer>
<address>
        © Яндекс, <a href="http://127.0.0.1:5500/help@yandex.ru"> help@yandex.ru</a>,
        Хохрякова, 10
</address>
</footer>
</body>
</html>
